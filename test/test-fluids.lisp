;;;; Fluid tests
;;;

#+org.tfeb.tools.require-module
(org.tfeb.tools.require-module:needs
 (:org.tfeb.toys.fluids :compile t)
  #+Quicklisp
  ("parachute" :fallback ql:quickload))

(defpackage :org.tfeb.toys.fluids/test
  (:use :cl :org.tfeb.toys.fluids :org.shirakumo.parachute))

(in-package :org.tfeb.toys.fluids/test)

(define-test "fluids")

(define-test ("fluids" "simple")
  (let ((f (make-fluid))
        (g (make-fluid :value 3)))
    ;; check bindery
    (is-values (fluid-boundp f)
      (eql nil)
      (eql nil))
    (is-values (fluid-boundp g)
      (eql t)
      (eql t))
    (is eql (fluid-value g) 3)
    (true (fluidp f))
    (false (fluidp 1))))

(define-test ("fluids" "make-fluid")
  (let ((f (make-fluid))
        (g (make-fluid :value 1)))
    (false (fluid-boundp (make-fluid :from f)))
    (true (fluid-boundp (make-fluid :from g)))
    (fluid-let ((f 2)
                (g 3))
      (false (fluid-boundp (make-fluid :from f)))
      (is eql (fluid-value (make-fluid :from g)) 1))))

(define-test ("fluids" "local and global")
  (let ((f (make-fluid :value 1)))
    (is eql (fluid-value f) 1)
    (fluid-let ((f 2))
      (is eql (fluid-value f) 2)
      (is eql (fluid-value f t) 1)
      (finish (setf (fluid-value f) 9))
      (is eql (fluid-value f) 9)
      (is eql (fluid-value f t) 1)
      (finish (setf (fluid-value f t) 8))
      (is eql (fluid-value f) 9)
      (is eql (fluid-value f t) 8))
    (is eql (fluid-value f) 8)))

(define-test ("fluids" "boundp")
  (let ((f (make-fluid :value 1))
        (g (make-fluid)))
    (is-values (fluid-boundp f)
      (eql t) (eql t))
    (is-values (fluid-boundp g)
      (eql nil) (eql nil))
    (fluid-let ((f 1) (g 2))
      (is-values (fluid-boundp g)
        (eql t) (eql nil))
      (is-values (fluid-boundp f)
        (eql t) (eql t)))
    (is-values (fluid-boundp f t)
      (eql t) (eql nil))
    (is-values (fluid-boundp g t)
      (eql nil) (eql nil))
    (fluid-let ((f 1) (g 2))
      (is-values (fluid-boundp f t)
        (eql t) (eql t))
      (is-values (fluid-boundp g t)
        (eql nil) (eql t)))))

(define-test ("fluids" "makunbound")
  (let ((f (make-fluid)))
    (is eql (fluid-makunbound f) f)
    (fluid-let ((f 1))
      (fail (fluid-makunbound f) bound-fluid-error))
    (fail (setf (fluid-value f) 2) unbound-fluid-error)
    (finish (setf (fluid-value f t) 2))
    (is-values (fluid-boundp f t)
      (eql t) (eql nil))
    (finish (fluid-makunbound f))
    (is-values (fluid-boundp f t)
      (eql nil) (eql nil))))

(define-test ("fluids" "fluid-value")
  (let ((f (make-fluid))
        (g (make-fluid :value 1)))
    (fail (fluid-value f) unbound-fluid-error)
    (finish (fluid-value g))
    (fail (setf (fluid-value f) 1) unbound-fluid-error)
    (finish (setf (fluid-value g) 1))
    (fluid-let ((f 1) (g 2))
      (finish (fluid-value f))
      (finish (fluid-value g))
      (finish (setf (fluid-value f) 3))
      (finish (setf (fluid-value g) 4))
      (is eql (fluid-value f) 3)
      (is eql (fluid-value g) 4))
    (false (fluid-boundp f))
    (true (fluid-boundp g))
    (is eql (fluid-value g) 1)))

(define-test ("fluids" "call/fluids-bindings")
  (let ((f (make-fluid :value 3)))
    (finish (call/fluid-bindings
             (lambda ())
             f 4))
    (is eql (call/fluid-bindings
             (lambda () (fluid-value f))
             f 4)
        4)
    (is eql (fluid-value f) 3)))

(define-test ("fluids" "fluid-let, fluid-let*")
  (let ((f (make-fluid :value 1))
        (g (make-fluid)))
    (is eql
        (fluid-let ((f 2) (g (fluid-value f)))
          (fluid-value g))
        1)
    (is eql
        (fluid-let* ((f 2) (g (fluid-value f)))
          (fluid-value g))
        2)))

(define-test ("fluids" "type checking")
  (let ((f (make-fluid)))
    (finish (call/fluid-bindings (lambda ()) f 1))
    (finish (fluid-let ((f 1))))
    (fail (call/fluid-bindings (lambda ()) 'x 1)
          type-error)
    (fail (fluid-let (('x 1)))
          type-error)))

(test "fluids" :report 'summary)
